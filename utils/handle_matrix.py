import json

def print_biarray(m: list):
    """Display bidimentional array in a cool way"""
    print('[')
    for line in m:
        print('    ' + json.dumps(line) + ',')
    print(']')

def get_direction(char: str) -> int:
    """Get direction of the next char based on the current char

    The values in d {dict} are arbitrary, based actually on the images
    that you can check at /imgs/alphabet -- the direction is based on
    the border line on each image. Here, 1 means down; 2 means left;
    3 means up, and; 4 means right.

    Arguments:
        char {str} -- Single character

    Returns:
        {int} -- Direction value
    """

    d = {
        ' ': 4, 'a': 4, 'b': 4, 'c': 4, 'd': 4, 'e': 4, 'f': 4,
        'g': 1, 'h': 1, 'i': 1, 'j': 1, 'k': 1, 'l': 1, 'm': 1,
        'n': 3, 'o': 3, 'p': 3, 'q': 3, 'r': 3, 's': 3, 't': 3,
        'u': 2, 'v': 2, 'w': 2, 'x': 2, 'y': 2, 'z': 2, '.': 2,
    }
    # 1 means down
    # 2 means left
    # 3 means up
    # 4 means right

    return d[char]

def get_text_array(t: str) -> list:
    """Get array with zeros on empty spaces and each letter/char at 
    the desired position

    The returned array will be base for the final image generated by 
    the main algorithm.

    Arguments:
        t {str} -- Processed text

    Returns:
        {list[list]} -- Bidimentional array with the text with proper
                        characters position
    """

    # CHANGING THIS CODE CAN BE PROBLEMATIC
    # I'M RETARDED AND THIS IS THE ONLY WAY I MADE IT WORK
    # THANKS

    # Initial array
    l = [[]]

    # Define first item position
    last_xi = 0
    last_yi = 0

    # Here we are using x for number/index of lines
    # And y for number/index of columns

    # For each char inside the string
    for c in t:
        if len(l) == 1 and len(l[0]) == 0:
            # Placing first char in position (0, 0)
            last_xi = 0
            last_yi = 0
            l[0].append(c.upper())
        else:
            # Any other char hits this part
            
            # Define variables for x and y shift
            x_offset = 0
            y_offset = 0
            
            # Defining x or y shift based on last char direction
            if di == 1:
                x_offset = 1
            elif di == 2:
                y_offset = -1
            elif di == 3:
                x_offset = -1
            elif di == 4:
                y_offset = 1
                
            xn = len(l) # Current number of lines
            yn = len(l[0]) # Current number of columns
            
            # Get non-handled desired position
            xi = last_xi + x_offset
            yi = last_yi + y_offset
            
            # Now we are solving the array problem
            solved = 0
            while not solved:
                if xi < 0:
                    # If position shift made xi be lower than 0, this 
                    # Means a new line of zeros needs to be added on 
                    # Top of the array
                    nli = [0 for i in range(yn)]
                    l = [nli, *l]
                    # Here xi is set to be 0, because it can't be 
                    # Lower than that
                    xi = 0
                elif xi > xn-1:
                    # If position shift made xi be greater than xn-1, 
                    # This means a new line of zero needs to be added 
                    # At the bottom of the array
                    nli = [0 for i in range(yn)]
                    l.append(nli)
                    # Here xi is set to be xn-1, because it can't be 
                    # Greater than that
                    xi = xn-1
                elif yi < 0:
                    # If position shift made yi be lower than 0, this 
                    # Means a new column of zeros needs to be added on
                    # The left of the array
                    for i in range(xn):
                        l[i] = [0, *l[i]]
                    # Here yi is set to be 0, because it can't be 
                    # Lower than that
                    yi = 0
                elif yi > yn-1:
                    # If position shift made yi be greater than yn-1, 
                    # This means a new column of zeros needs to be 
                    # Added on the right of the array
                    for i in range(xn):
                        l[i].append(0)
                    # Here yi is set to be yn-1, because it can't be 
                    # Greater than that
                    yi = yn-1
                else: 
                    # Sometimes the position shift doesn't seem to 
                    # Need to change the array configuration, but the 
                    # Given direction resulted on a position that is 
                    # Already in use, this means that actually the 
                    # Array needs to be changed, so we continue the 
                    # Loop, adding the offsets again to the xi and yi 
                    # Variables
                    v = l[xi][yi]
                    if v != 0:
                        xi += x_offset
                        yi += y_offset
                        continue

                # If the excution hits this line, this means
                # The array configuration has already been solved
                # So this is the end to the loop
                solved = 1
                
            # Assuming the array configuration is already solved
            # We handle the same issue about the target position been 
            # Already used by an old value, but it is not needed to 
            # Add lines or columns to the array, only finding an empty
            # Position
            v = l[xi][yi]
            while v != 0:
                if x_offset == 0:
                    yi += y_offset
                elif y_offset == 0:
                    xi += x_offset

                v = l[xi][yi]
            
            # Then the new value is passed to the final position
            l[xi][yi] = c
            
            # Changed these because... you know
            last_xi = xi
            last_yi = yi
            
        # Get char direction
        # It defines the direction of the next char
        di = get_direction(c)
        
    return l

if __name__ == '__main__':
    text = 'amora'
    l = get_text_array(text)
    print_biarray(l)